<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Winter Cat: Debug Mode</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@800;900&display=swap" rel="stylesheet">
    
    <style>
        :root { --bg-deep: #020617; --ui-glass: rgba(15, 23, 42, 0.85); --accent: #38bdf8; }
        body { margin: 0; background-color: var(--bg-deep); color: white; font-family: 'Nunito', sans-serif; overflow: hidden; touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; }
        #game-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: flex; flex-direction: column; justify-content: space-between; padding: 15px; box-sizing: border-box; transition: opacity 0.3s; }
        .hidden { opacity: 0; pointer-events: none; }
        .top-bar { display: flex; gap: 5px; justify-content: space-between; width: 100%; }
        .stat-box { background: var(--ui-glass); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.15); border-radius: 12px; padding: 4px 8px; display: flex; align-items: center; gap: 4px; box-shadow: 0 4px 15px rgba(0,0,0,0.4); flex: 1; justify-content: center; min-width: 0; }
        .stat-val { font-size: 14px; font-weight: 900; text-shadow: 0 2px 2px rgba(0,0,0,0.5); white-space: nowrap; }
        .icon { font-size: 18px; }
        .bottom-bar { display: flex; justify-content: center; align-items: flex-end; pointer-events: none; padding-bottom: 20px; position: relative; width: 100%; height: 100px; }
        .btn-finish { pointer-events: auto; background: linear-gradient(180deg, #22c55e 0%, #16a34a 100%); border: none; border-top: 2px solid #86efac; padding: 12px 25px; border-radius: 16px; color: white; font-family: 'Nunito', sans-serif; font-size: 18px; font-weight: 900; box-shadow: 0 4px 15px rgba(22, 163, 74, 0.5); cursor: pointer; text-transform: uppercase; position: absolute; bottom: 10px; right: 0; }
        .btn-finish:active { transform: scale(0.95); }
        .log-bubble { background: rgba(0,0,0,0.7); color: #bae6fd; padding: 10px 24px; border-radius: 30px; font-size: 15px; font-weight: 800; border: 1px solid rgba(56, 189, 248, 0.3); opacity: 0; transition: opacity 0.3s, transform 0.3s; transform: translateY(20px); backdrop-filter: blur(4px); text-align: center; margin-bottom: 50px; }
        .log-bubble.show { opacity: 1; transform: translateY(0); }
        .menu-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(2, 6, 23, 0.85); backdrop-filter: blur(15px); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; transition: opacity 0.5s ease-in-out; }
        .menu-screen.closed { opacity: 0; pointer-events: none; }
        .title { font-size: 42px; font-weight: 900; background: linear-gradient(to bottom, #fff, #7dd3fc); -webkit-background-clip: text; background-clip: text; color: transparent; margin-bottom: 40px; text-transform: uppercase; filter: drop-shadow(0 0 20px rgba(56, 189, 248, 0.6)); text-align: center; line-height: 1.1; }
        .btn-play { position: relative; background: linear-gradient(180deg, #0ea5e9 0%, #0284c7 100%); border: none; border-top: 2px solid #bae6fd; padding: 20px 70px; border-radius: 24px; color: white; font-family: 'Nunito', sans-serif; font-size: 24px; font-weight: 900; box-shadow: 0 10px 30px rgba(2, 132, 199, 0.6), 0 5px 0 #0369a1; cursor: pointer; transition: transform 0.1s; margin-bottom: 20px; text-transform: uppercase; }
        .btn-play:active { transform: translateY(4px); box-shadow: 0 0 0 #0369a1; }
        .loader { border: 4px solid rgba(255,255,255,0.1); border-left-color: #38bdf8; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; display: none; margin-bottom: 20px;}
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .save-indicator { position: absolute; top: 10px; right: 10px; font-size: 10px; color: #4ade80; opacity: 0; transition: opacity 0.5s; font-weight: bold; display: flex; align-items: center; gap: 4px;}
        .save-indicator.show { opacity: 1; }
        .menu-snow { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; background-image: url('data:image/svg+xml;utf8,<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><circle cx="10" cy="10" r="2" fill="white" opacity="0.5"/><circle cx="50" cy="80" r="1.5" fill="white" opacity="0.5"/><circle cx="150" cy="30" r="3" fill="white" opacity="0.5"/><circle cx="100" cy="150" r="2" fill="white" opacity="0.5"/></svg>'); animation: snowScroll 20s linear infinite; }
        @keyframes snowScroll { from { background-position: 0 0; } to { background-position: 0 500px; } }
        
        /* üî• –í–ò–ó–£–ê–õ–¨–ù–ê–Ø –ö–û–ù–°–û–õ–¨ –î–õ–Ø –¢–ï–õ–ï–§–û–ù–ê üî• */
        #console-log {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 150px;
            background: rgba(0,0,0,0.85); color: #00ff00; 
            font-family: 'Courier New', monospace; font-size: 11px;
            overflow-y: scroll; z-index: 9999; padding: 8px; 
            pointer-events: auto; border-top: 2px solid #38bdf8;
            white-space: pre-wrap; word-break: break-all;
        }
    </style>
</head>
<body>

    <div id="game-container"></div>
    
    <div id="console-log">üöÄ SYSTEM START...<br></div>

    <div class="ui-layer hidden" id="game-ui">
        <div class="top-bar">
            <div class="stat-box" style="border-bottom: 3px solid #38bdf8;">
                <span class="icon">‚ö°</span>
                <span class="stat-val" id="energy-txt">--</span>
            </div>
            <div class="stat-box" style="border-bottom: 3px solid #888;">
                <span class="icon">üìç</span>
                <span class="stat-val" id="coords-txt">0,0</span>
            </div>
            <div class="stat-box" style="border-bottom: 3px solid #fbbf24;">
                <span class="icon">üçä</span>
                <span class="stat-val" id="loot-txt">0</span>
            </div>
            <div class="stat-box" style="border-bottom: 3px solid #ffffff;">
                <span class="icon">üí∞</span>
                <span class="stat-val" id="coin-txt">0</span>
            </div>
        </div>
        <div class="save-indicator" id="save-icon">‚òÅÔ∏è Saved</div>
        <div class="bottom-bar">
            <div class="log-bubble" id="log"></div>
            <button class="btn-finish" onclick="finishGame()">üéí –ó–ê–ë–†–ê–¢–¨</button>
        </div>
    </div>

    <div class="menu-screen" id="main-menu">
        <div class="menu-snow"></div>
        <div class="title">–ó–∏–º–Ω–∏–π<br>–ö–æ—Ç</div>
        <div class="loader" id="loader"></div>
        <button class="btn-play" id="btn-play" onclick="startGame()">–ò–ì–†–ê–¢–¨</button>
        <div style="margin-top:10px; font-size:12px; color:#64748b;" id="status-text">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...</div>
    </div>

<script>
    // --- –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –í–´–í–û–î–ê –õ–û–ì–û–í –ù–ê –≠–ö–†–ê–ù ---
    function debugLog(msg) {
        console.log(msg);
        const logDiv = document.getElementById('console-log');
        if (logDiv) {
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${time}] ${msg}<br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }
    }
    
    // –ü–µ—Ä–µ—Ö–≤–∞—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –æ—à–∏–±–æ–∫ JS
    window.onerror = function(msg, url, line) {
        debugLog(`‚ùå ERROR: ${msg} (Line: ${line})`);
        return false;
    };

    const tg = window.Telegram.WebApp;
    tg.expand();
    tg.ready();

    // --- –ö–õ–Æ–ß–ò SUPABASE ---
    const SUPABASE_URL = "https://jnavsekwmitcajgvfafk.supabase.co";
    const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpuYXZzZWt3bWl0Y2FqZ3ZmYWZrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg2MDU1OTIsImV4cCI6MjA3NDE4MTU5Mn0.0NmAYM2hgzR7emeg45WpoSgqiHYizmtj8dGhMK7FOS4";
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

    let userId = tg.initDataUnsafe?.user?.id ? String(tg.initDataUnsafe.user.id) : null;
    
    // –î–ª—è —Ç–µ—Å—Ç–æ–≤ –≤ –±—Ä–∞—É–∑–µ—Ä–µ (–µ—Å–ª–∏ –Ω–µ—Ç TG)
    if (!userId) {
        const urlParams = new URLSearchParams(window.location.search);
        userId = urlParams.get('user_id') || 'test_user'; 
        debugLog("‚ö†Ô∏è UserId –∏–∑ URL/Default: " + userId);
    } else {
        debugLog("‚úÖ UserId –∏–∑ Telegram: " + userId);
    }

    let game = null;
    let gameScene = null;
    let isGameActive = false;
    let unsavedChanges = false;
    let saveTimeout = null;

    let sessionData = {
        x: 0, y: 0,
        energy: 50,
        loot: 0, coins: 0, gifts: 0
    };

    // --- –õ–û–ì–ò–ö–ê –ó–ê–ì–†–£–ó–ö–ò –° –ê–í–¢–û-–°–û–ó–î–ê–ù–ò–ï–ú –ò–ì–†–û–ö–ê ---
    async function loadFromCloud() {
        updateStatus("–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è...", true);
        debugLog("üì° –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Supabase...");
        
        try {
            // 1. –ü–æ–ø—ã—Ç–∫–∞ —á—Ç–µ–Ω–∏—è (–±–µ–∑ single, —á—Ç–æ–±—ã –Ω–µ –ø–∞–¥–∞–ª–æ)
            let { data, error } = await supabase.from('users')
                .select('minigame_state, minigame_energy, minigame_temp_loot')
                .eq('id', userId);

            if (error) {
                debugLog("‚õî –û—à–∏–±–∫–∞ SELECT: " + JSON.stringify(error));
                throw error;
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –¥–∞–Ω–Ω—ã–µ
            if (!data || data.length === 0) {
                debugLog("‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–æ–∑–¥–∞—é...");
                
                // 2. –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                const newUserData = {
                    id: userId,
                    cat_name: '–ö–æ—Ç', 
                    minigame_energy: 50
                };

                const { error: insertError } = await supabase.from('users').insert([newUserData]);

                if (insertError) {
                    debugLog("‚õî –û—à–∏–±–∫–∞ INSERT: " + JSON.stringify(insertError));
                    throw insertError;
                }

                debugLog("‚úÖ –ü—Ä–æ—Ñ–∏–ª—å —Å–æ–∑–¥–∞–Ω —É—Å–ø–µ—à–Ω–æ!");
                sessionData = { x: 0, y: 0, energy: 50, loot: 0, coins: 0, gifts: 0 };
                updateStatus("–ü—Ä–æ—Ñ–∏–ª—å —Å–æ–∑–¥–∞–Ω!", false);
                return true;
            }

            // 3. –î–∞–Ω–Ω—ã–µ –Ω–∞–π–¥–µ–Ω—ã
            debugLog("‚úÖ –ü—Ä–æ—Ñ–∏–ª—å –Ω–∞–π–¥–µ–Ω. –ó–∞–≥—Ä—É–∑–∫–∞...");
            const userData = data[0];

            if (userData.minigame_state) {
                sessionData.x = userData.minigame_state.x || 0;
                sessionData.y = userData.minigame_state.y || 0;
            }
            sessionData.energy = userData.minigame_energy !== null ? userData.minigame_energy : 50;
            
            if (userData.minigame_temp_loot) {
                sessionData.loot = userData.minigame_temp_loot.loot || 0;
                sessionData.coins = userData.minigame_temp_loot.coins || 0;
                sessionData.gifts = userData.minigame_temp_loot.gifts || 0;
            }
            
            debugLog(`üìç Pos: ${sessionData.x},${sessionData.y} ‚ö° Energy: ${sessionData.energy}`);
            updateStatus("–ì–æ—Ç–æ–≤–æ!", false);
            return true;

        } catch (e) {
            debugLog("üî• CRITICAL ERROR: " + e.message);
            updateStatus("–û—à–∏–±–∫–∞. –ò–≥—Ä–∞—é –ª–æ–∫–∞–ª—å–Ω–æ.", false);
        }
        return false;
    }

    async function saveToCloud() {
        if (!unsavedChanges) return;
        
        const payload = {
            p_user_id: userId,
            p_x: sessionData.x,
            p_y: sessionData.y,
            p_energy: sessionData.energy,
            p_loot: { 
                loot: sessionData.loot, 
                coins: sessionData.coins, 
                gifts: sessionData.gifts 
            }
        };

        const indicator = document.getElementById('save-icon');
        indicator.classList.add('show');

        try {
            const { error } = await supabase.rpc('autosave_game_progress', payload);
            if (error) {
                debugLog("‚ö†Ô∏è –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: " + error.message);
                throw error;
            }
            
            unsavedChanges = false;
            setTimeout(() => indicator.classList.remove('show'), 500);
        } catch (e) {
            console.error("Save error:", e);
        }
    }

    function scheduleSave() {
        unsavedChanges = true;
        if (saveTimeout) clearTimeout(saveTimeout);
        saveTimeout = setTimeout(saveToCloud, 2000);
    }

    function updateStatus(msg, loading) {
        document.getElementById('status-text').innerText = msg;
        document.getElementById('loader').style.display = loading ? 'block' : 'none';
        document.getElementById('btn-play').style.display = loading ? 'none' : 'block';
    }

    // --- –î–í–ò–ñ–û–ö –ò–ì–†–´ (PHASER & AUDIO) ---
    const AudioEngine = {
        ctx: null, masterGain: null, windNode: null, windGain: null, slideNode: null, slideGain: null, isSliding: false,
        init: function() {
            try {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.8; 
                this.masterGain.connect(this.ctx.destination);
                this.initWind();
                debugLog("üîä Audio init OK");
            } catch (e) {
                debugLog("üîá Audio init FAIL: " + e.message);
            }
        },
        initWind: function() {
            if(!this.ctx) return;
            const bufferSize = this.ctx.sampleRate * 2;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0; 
            for (let i = 0; i < bufferSize; i++) {
                let white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 3.5; 
            }
            this.windNode = this.ctx.createBufferSource();
            this.windNode.buffer = buffer;
            this.windNode.loop = true;
            this.windFilter = this.ctx.createBiquadFilter();
            this.windFilter.type = 'lowpass';
            this.windFilter.frequency.value = 400;
            this.windGain = this.ctx.createGain();
            this.windGain.gain.value = 0.05; 
            this.windNode.connect(this.windFilter);
            this.windFilter.connect(this.windGain);
            this.windGain.connect(this.masterGain);
            this.windNode.start();
            setInterval(() => {
                if(!isGameActive) return;
                const time = this.ctx.currentTime;
                const newVol = 0.05 + Math.random() * 0.15;
                const dur = 2 + Math.random() * 3;
                this.windGain.gain.linearRampToValueAtTime(newVol, time + dur/2);
                this.windGain.gain.linearRampToValueAtTime(0.05, time + dur);
                const newFreq = 300 + Math.random() * 600;
                this.windFilter.frequency.exponentialRampToValueAtTime(newFreq, time + dur/2);
                this.windFilter.frequency.exponentialRampToValueAtTime(400, time + dur);
            }, 5000);
        },
        playTone: function(freq, type, duration, vol=0.1) {
            if(!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },
        playCrunchNoise: function() {
            if(!this.ctx) return;
            const t = this.ctx.currentTime;
            const duration = 0.14; 
            const bufferSize = this.ctx.sampleRate * duration;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) { data[i] = (Math.random() * 2 - 1) * 0.5; }
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 1100 + (Math.random() * 200 - 100); 
            filter.Q.value = 0.8; 
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.6, t + 0.015); 
            gain.gain.exponentialRampToValueAtTime(0.01, t + duration);
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            noise.start();
        },
        startSlideSound: function() {
            if(!this.ctx || this.isSliding) return;
            this.isSliding = true;
            const bufferSize = this.ctx.sampleRate * 2; 
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
            this.slideNode = this.ctx.createBufferSource();
            this.slideNode.buffer = buffer;
            this.slideNode.loop = true;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 2500; 
            filter.Q.value = 4;
            this.slideGain = this.ctx.createGain();
            this.slideGain.gain.setValueAtTime(0, this.ctx.currentTime);
            this.slideGain.gain.linearRampToValueAtTime(0.15, this.ctx.currentTime + 0.3);
            this.slideNode.connect(filter);
            filter.connect(this.slideGain);
            this.slideGain.connect(this.masterGain);
            this.slideNode.start();
        },
        stopSlideSound: function() {
            if(!this.ctx || !this.isSliding) return;
            const t = this.ctx.currentTime;
            this.slideGain.gain.cancelScheduledValues(t);
            this.slideGain.gain.setValueAtTime(this.slideGain.gain.value, t);
            this.slideGain.gain.linearRampToValueAtTime(0, t + 0.2);
            const node = this.slideNode;
            setTimeout(() => { if(node) node.stop(); }, 250);
            this.isSliding = false;
        },
        step: function() { this.playCrunchNoise(); },
        coin: function() { this.playTone(1500, 'sine', 0.2, 0.15); setTimeout(()=>this.playTone(2000, 'sine', 0.3, 0.15), 60); }, 
        bump: function() { this.playTone(100, 'square', 0.1, 0.2); }
    };

    const catSvg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200" width="200" height="200">
    <defs>
        <linearGradient id="fur" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color:#ffb347;stop-opacity:1" /><stop offset="100%" style="stop-color:#ffcc33;stop-opacity:1" /></linearGradient>
        <filter id="softShadow" x="-20%" y="-20%" width="140%" height="140%"><feGaussianBlur in="SourceAlpha" stdDeviation="4"/><feOffset dx="0" dy="4" result="offsetblur"/><feComponentTransfer><feFuncA type="linear" slope="0.3"/></feComponentTransfer><feMerge><feMergeNode in="offsetblur"/></feMerge></filter>
    </defs>
    <ellipse cx="100" cy="180" rx="60" ry="15" fill="rgba(0,0,0,0.25)" />
    <path d="M40 70 L45 20 L90 60 Z" fill="url(#fur)" stroke="#d97706" stroke-width="4" stroke-linejoin="round"/>
    <path d="M160 70 L155 20 L110 60 Z" fill="url(#fur)" stroke="#d97706" stroke-width="4" stroke-linejoin="round"/>
    <path d="M50 60 L52 35 L75 55 Z" fill="#fecaca" />
    <path d="M150 60 L148 35 L125 55 Z" fill="#fecaca" />
    <ellipse cx="100" cy="110" rx="70" ry="60" fill="rgba(0,0,0,1)" filter="url(#softShadow)"/>
    <ellipse cx="100" cy="110" rx="70" ry="60" fill="url(#fur)" stroke="#d97706" stroke-width="4"/>
    <path d="M32 110 L20 105 L30 120 L22 130 L35 135" fill="#ffb347" stroke="#d97706" stroke-width="3" stroke-linejoin="round"/>
    <path d="M168 110 L180 105 L170 120 L178 130 L165 135" fill="#ffb347" stroke="#d97706" stroke-width="3" stroke-linejoin="round"/>
    <g transform="rotate(-5, 100, 50)"><path d="M40 65 Q100 80 160 65 L160 75 Q100 90 40 75 Z" fill="#ffffff" stroke="#cbd5e1" stroke-width="2"/><path d="M150 70 Q180 90 170 120 L130 80" fill="#dc2626" stroke="#991b1b" stroke-width="3"/><path d="M40 75 Q100 20 160 75" fill="#dc2626" stroke="#991b1b" stroke-width="3"/><circle cx="170" cy="120" r="12" fill="#ffffff" stroke="#cbd5e1" stroke-width="2"/></g>
    <ellipse cx="100" cy="125" rx="25" ry="18" fill="#ffedd5" /> <circle cx="75" cy="105" r="10" fill="#1a1a1a"/>
    <circle cx="71" cy="101" r="4" fill="#ffffff"/>
    <circle cx="125" cy="105" r="10" fill="#1a1a1a"/>
    <circle cx="121" cy="101" r="4" fill="#ffffff"/>
    <path d="M94 118 L106 118 L100 124 Z" fill="#ef4444" stroke="#b91c1c" stroke-width="1" stroke-linejoin="round"/>
    <path d="M100 124 Q90 135 80 128 M100 124 Q110 135 120 128" stroke="#1a1a1a" stroke-width="3" fill="none" stroke-linecap="round"/>
    <path d="M60 120 L25 115 M60 125 L20 128 M60 130 L25 138" stroke="#000" stroke-width="2" />
    <path d="M140 120 L175 115 M140 125 L180 128 M140 130 L175 138" stroke="#000" stroke-width="2" />
    </svg>`;

    class GameScene extends Phaser.Scene {
        constructor() {
            super('GameScene');
            this.TILE_SIZE = 70;
            this.CHUNK_SIZE = 16;
            this.chunks = new Map();
            this.isSliding = false;
            
            this.COLORS = {
                snowTop: 0xf1f5f9, snowSide: 0x94a3b8,
                iceTop: 0xbae6fd, iceSide: 0x38bdf8,
                fog: 0x020617
            };
        }

        create() {
            this.createTextures();
            this.tileGroup = this.add.group();
            this.objGroup = this.add.group();

            const catText = this.add.text(0, 0, 'üê±', { fontSize: '50px' }).setOrigin(0.5, 0.8).setDepth(100);
            this.catSprite = catText;

            // –ì—Ä—É–∑–∏–º –∫–∞—Ä—Ç–∏–Ω–∫—É –∏–∑ SVG
            const canvas = document.createElement('canvas');
            canvas.width = 200; canvas.height = 200;
            const ctx = canvas.getContext('2d');
            const img = new Image();
            img.onload = () => {
                ctx.drawImage(img, 0, 0, 200, 200);
                if (this.textures.exists('cat')) this.textures.remove('cat');
                this.textures.addCanvas('cat', canvas);
                if (this.catSprite) {
                    const x = this.catSprite.x; const y = this.catSprite.y;
                    this.catSprite.destroy();
                    this.catSprite = this.add.sprite(x, y, 'cat').setDepth(100);
                    this.catSprite.setDisplaySize(60, 60);
                    this.catSprite.setOrigin(0.5, 0.8);
                    this.cameras.main.startFollow(this.catSprite, true, 0.1, 0.1);
                }
            };
            img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(catSvg);

            this.cameras.main.setBackgroundColor('#020617');
            this.cameras.main.startFollow(this.catSprite, true, 0.1, 0.1);
            
            this.updateCameraZoom();
            this.scale.on('resize', this.updateCameraZoom, this);
            
            this.input.on('pointerdown', (pointer) => this.handleInput(pointer));
            this.initMap();
        }

        updateCameraZoom() {
            const width = this.scale.width;
            let zoom = width / 560;
            if (zoom < 0.8) zoom = 0.8; if (zoom > 2.0) zoom = 2.0;
            this.cameras.main.setZoom(zoom);
        }

        createTextures() {
            const g = this.make.graphics({x:0, y:0, add:false});
            const ts = this.TILE_SIZE;
            g.clear();
            g.fillStyle(this.COLORS.snowSide); g.fillRect(2, ts/2 + 2, ts-4, (ts/2)+4);
            g.fillStyle(this.COLORS.snowTop); g.fillRoundedRect(2, 2, ts-4, ts-4, 4);
            g.generateTexture('tile_snow', ts, ts);
            
            g.clear();
            g.fillStyle(this.COLORS.iceSide); g.fillRect(2, ts/2 + 2, ts-4, ts/2 + 4);
            g.fillStyle(this.COLORS.iceTop); g.fillRoundedRect(2, 2, ts-4, ts-4, 4);
            g.fillStyle(0xffffff, 0.4); 
            g.beginPath(); g.moveTo(10, ts-15); g.lineTo(ts-15, 15); g.lineTo(ts-25, 15); g.lineTo(10, ts-25); 
            g.fillPath();
            g.generateTexture('tile_ice', ts, ts);

            g.clear();
            g.fillStyle(this.COLORS.fog); g.fillRect(0, 0, ts, ts);
            g.generateTexture('tile_fog', ts, ts);
            g.destroy();
            
            this.createEmojiTexture('tex_tree', 'üéÑ', 50, '#22c55e', true);
            this.createEmojiTexture('tex_star', '‚≠ê', 20, '#fbbf24', true);
            this.createEmojiTexture('tex_orange', 'üçä', 30, '#fbbf24', true);
            this.createEmojiTexture('tex_coin', 'üí∞', 30, '#ffffff', true);
            this.createEmojiTexture('tex_gift', 'üéÅ', 30, '#f472b6', true);
        }
        
        createEmojiTexture(key, emoji, fontSize, glowColor, circleOutline) {
            const canvas = document.createElement('canvas');
            canvas.width = 80; canvas.height = 80;
            const ctx = canvas.getContext('2d');
            if(circleOutline && key !== 'tex_tree' && key !== 'tex_star') {
                ctx.strokeStyle = glowColor; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(40, 40, 16, 0, Math.PI*2);
                ctx.globalAlpha = 0.3; ctx.stroke(); ctx.globalAlpha = 1.0;
            }
            ctx.font = `${fontSize}px serif`;
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.shadowColor = glowColor; ctx.shadowBlur = 15;
            ctx.fillText(emoji, 40, 40);
            this.textures.addCanvas(key, canvas);
        }

        initMap() {
            this.tileGroup.clear(true, true);
            this.objGroup.clear(true, true);
            this.chunks.clear();
            
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º sessionData, –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –∏–∑ –æ–±–ª–∞–∫–∞
            const startX = sessionData.x * this.TILE_SIZE + this.TILE_SIZE/2;
            const startY = sessionData.y * this.TILE_SIZE + this.TILE_SIZE/2;
            this.catSprite.setPosition(startX, startY);
            
            this.revealFog(sessionData.x, sessionData.y);
            this.updateView();
            updateHTMLStats();
        }

        getChunk(cx, cy) {
            const key = `${cx},${cy}`;
            if (this.chunks.has(key)) return this.chunks.get(key);
            const chunk = [];
            for (let y = 0; y < this.CHUNK_SIZE; y++) {
                const row = [];
                for (let x = 0; x < this.CHUNK_SIZE; x++) {
                    const gx = cx * this.CHUNK_SIZE + x;
                    const gy = cy * this.CHUNK_SIZE + y;
                    let type = 'snow'; let obj = null;
                    const iceNoise = Math.sin(gx * 0.2) * Math.cos(gy * 0.2);
                    const r = Math.random();
                    
                    if (iceNoise > 0.45) type = 'ice';
                    else {
                        if (r < 0.12) obj = 'tree';
                        else if (r < 0.15) obj = 'loot'; 
                        else if (r < 0.17) obj = 'coin'; 
                        else if (r < 0.175) obj = 'gift'; 
                    }
                    if (Math.abs(gx) < 2 && Math.abs(gy) < 2) { type = 'snow'; obj = null; }
                    row.push({ gx, gy, type, obj, revealed: false, sprite: null, objSprite: null });
                }
                chunk.push(row);
            }
            this.chunks.set(key, chunk);
            return chunk;
        }

        getTileData(gx, gy) {
            const cx = Math.floor(gx / this.CHUNK_SIZE);
            const cy = Math.floor(gy / this.CHUNK_SIZE);
            const chunk = this.getChunk(cx, cy);
            let lx = ((gx % this.CHUNK_SIZE) + this.CHUNK_SIZE) % this.CHUNK_SIZE;
            let ly = ((gy % this.CHUNK_SIZE) + this.CHUNK_SIZE) % this.CHUNK_SIZE;
            return chunk[ly][lx];
        }

        updateView() {
            const range = 6;
            const px = sessionData.x;
            const py = sessionData.y;

            for(let dy = -range; dy <= range; dy++) {
                for(let dx = -range; dx <= range; dx++) {
                    const gx = px + dx; const gy = py + dy;
                    const tile = this.getTileData(gx, gy);
                    const wx = gx * this.TILE_SIZE + this.TILE_SIZE/2;
                    const wy = gy * this.TILE_SIZE + this.TILE_SIZE/2;

                    if (!tile.sprite) {
                        tile.sprite = this.add.image(wx, wy, 'tile_fog');
                        tile.sprite.setDisplaySize(this.TILE_SIZE, this.TILE_SIZE);
                        this.tileGroup.add(tile.sprite);
                    }
                    if (tile.revealed) {
                        const texKey = tile.type === 'ice' ? 'tile_ice' : 'tile_snow';
                        if(tile.sprite.texture.key !== texKey) tile.sprite.setTexture(texKey);
                        
                        if(tile.obj && !tile.objSprite) {
                            if(tile.obj === 'tree') {
                                const tree = this.add.image(wx, wy - 10, 'tex_tree');
                                tree.setDisplaySize(50, 50);
                                const star = this.add.image(wx, wy - 35, 'tex_star');
                                star.setDisplaySize(30, 30);
                                this.tweens.add({ targets: star, alpha: 0.5, duration: 800, yoyo: true, repeat: -1 });
                                tile.objSprite = [tree, star];
                                this.objGroup.add(tree); this.objGroup.add(star);
                            } else {
                                let key = tile.obj === 'loot' ? 'tex_orange' : (tile.obj === 'coin' ? 'tex_coin' : 'tex_gift');
                                const item = this.add.image(wx, wy, key);
                                item.setDisplaySize(50, 50);
                                this.tweens.add({ targets: item, y: wy - 5, duration: 1000, yoyo: true, repeat: -1, ease: 'Sine.easeInOut' });
                                tile.objSprite = item;
                                this.objGroup.add(item);
                            }
                        }
                    } else {
                        if(tile.sprite.texture.key !== 'tile_fog') tile.sprite.setTexture('tile_fog');
                        if(tile.objSprite) {
                            if(Array.isArray(tile.objSprite)) tile.objSprite.forEach(s => s.destroy());
                            else tile.objSprite.destroy();
                            tile.objSprite = null;
                        }
                    }
                }
            }
        }

        handleInput(pointer) {
            if (!isGameActive || this.isSliding) return;
            const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
            const gx = Math.floor(worldPoint.x / this.TILE_SIZE);
            const gy = Math.floor(worldPoint.y / this.TILE_SIZE);
            if (Math.abs(gx - sessionData.x) + Math.abs(gy - sessionData.y) === 1) {
                this.step(gx - sessionData.x, gy - sessionData.y);
            }
        }

        async step(dx, dy) {
            if (sessionData.energy <= 0) { showLog("–°–∏–ª –Ω–µ—Ç! –ù–∞–∂–º–∏ –ó–∞–±—Ä–∞—Ç—å üéí"); return; }
            
            const tx = sessionData.x + dx;
            const ty = sessionData.y + dy;
            const tile = this.getTileData(tx, ty);

            if (tile.obj === 'tree') { AudioEngine.bump(); showLog("–Å–ª–∫–∞! üéÑ"); return; }

            if(!this.isSliding) AudioEngine.step();

            sessionData.energy -= 1;
            
            const targetX = (sessionData.x + dx) * this.TILE_SIZE + this.TILE_SIZE/2;
            const targetY = (sessionData.y + dy) * this.TILE_SIZE + this.TILE_SIZE/2;
            
            this.tweens.add({
                targets: this.catSprite, x: targetX, y: targetY, duration: 150,
                onComplete: () => {
                    sessionData.x += dx; sessionData.y += dy;
                    this.checkLoot(sessionData.x, sessionData.y);
                    this.revealFog(sessionData.x, sessionData.y);
                    this.updateView();
                    updateHTMLStats();
                    
                    scheduleSave();
                    
                    if (tile.type === 'ice') {
                        this.isSliding = true;
                        AudioEngine.startSlideSound();
                        this.slideLoop(dx, dy);
                    }
                }
            });
        }
        
        slideLoop(dx, dy) {
            const nx = sessionData.x + dx;
            const ny = sessionData.y + dy;
            const nextTile = this.getTileData(nx, ny);
            
            if (nextTile.obj === 'tree' || nextTile.type !== 'ice') {
                this.isSliding = false;
                AudioEngine.stopSlideSound();
                scheduleSave();
                if (nextTile.obj === 'tree') AudioEngine.bump();
                else {
                    const tx = (sessionData.x + dx) * this.TILE_SIZE + this.TILE_SIZE/2;
                    const ty = (sessionData.y + dy) * this.TILE_SIZE + this.TILE_SIZE/2;
                    this.tweens.add({
                        targets: this.catSprite, x: tx, y: ty, duration: 150,
                        onComplete: () => {
                            sessionData.x += dx; sessionData.y += dy;
                            this.checkLoot(sessionData.x, sessionData.y);
                            this.revealFog(sessionData.x, sessionData.y);
                            this.updateView();
                            updateHTMLStats();
                            scheduleSave();
                        }
                    });
                }
            } else {
                const tx = (sessionData.x + dx) * this.TILE_SIZE + this.TILE_SIZE/2;
                const ty = (sessionData.y + dy) * this.TILE_SIZE + this.TILE_SIZE/2;
                this.tweens.add({
                    targets: this.catSprite, x: tx, y: ty, duration: 80,
                    onComplete: () => {
                        sessionData.x += dx; sessionData.y += dy;
                        this.checkLoot(sessionData.x, sessionData.y);
                        this.revealFog(sessionData.x, sessionData.y);
                        this.updateView();
                        updateHTMLStats();
                        this.slideLoop(dx, dy);
                    }
                });
            }
        }

        checkLoot(gx, gy) {
            const tile = this.getTileData(gx, gy);
            if (!tile.obj || tile.obj === 'tree') return;
            
            const wx = gx * this.TILE_SIZE + this.TILE_SIZE / 2;
            const wy = gy * this.TILE_SIZE + this.TILE_SIZE / 2;
            
            if (tile.obj === 'loot') { 
                sessionData.loot++; 
                AudioEngine.coin();
                this.spawnFloater(wx, wy, "+1 üçä", "#fbbf24");
            } 
            else if (tile.obj === 'coin') { 
                sessionData.coins += 5; 
                AudioEngine.coin();
                this.spawnFloater(wx, wy, "+5 üí∞", "#ffffff");
            } 
            else if (tile.obj === 'gift') { 
                sessionData.gifts++; 
                AudioEngine.coin();
                this.spawnFloater(wx, wy, "+1 üéÅ", "#f472b6");
            }
        
            if(tile.objSprite) {
                if(Array.isArray(tile.objSprite)) tile.objSprite.forEach(s => s.destroy());
                else tile.objSprite.destroy();
            }
            tile.obj = null; tile.objSprite = null;
        }
        
        spawnFloater(x, y, text, color) {
            const txt = this.add.text(x, y, text, {
                fontFamily: 'Nunito', fontSize: '18px', fontStyle: 'bold', 
                color: color, stroke: '#000', strokeThickness: 3
            }).setOrigin(0.5);
            this.tweens.add({ targets: txt, y: y - 50, alpha: 0, duration: 1000, onComplete: () => txt.destroy() });
        }

        revealFog(px, py) {
            for(let dy=-1; dy<=1; dy++) {
                for(let dx=-1; dx<=1; dx++) {
                    this.getTileData(px+dx, py+dy).revealed = true;
                }
            }
        }
    }

    async function startGame() {
        try { AudioEngine.init(); } catch(e) {}
        
        await loadFromCloud();
        
        if (!game) {
            const config = {
                type: Phaser.AUTO, parent: 'game-container', backgroundColor: '#020617',
                scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH },
                scene: GameScene, physics: { default: 'arcade', arcade: { debug: false } }
            };
            game = new Phaser.Game(config);
            setTimeout(() => {
                gameScene = game.scene.scenes[0];
                document.getElementById('main-menu').classList.add('closed');
                document.getElementById('game-ui').classList.remove('hidden');
                isGameActive = true;
                showLog("–õ–µ—Å –∂–¥—ë—Ç! –¢–∞–ø–∞–π —Ä—è–¥–æ–º —Å –∫–æ—Ç–æ–º üê±");
            }, 100);
        } else {
            document.getElementById('main-menu').classList.add('closed');
            document.getElementById('game-ui').classList.remove('hidden');
            isGameActive = true;
            gameScene.initMap(); 
            showLog("–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º! üéÑ");
        }
    }

    async function finishGame() {
        await saveToCloud();
        
        const results = {
            loot: sessionData.loot,
            coins: sessionData.coins,
            gifts: sessionData.gifts,
            x: sessionData.x,
            y: sessionData.y,
            energy: sessionData.energy,
            final: true
        };
        
        try {
            tg.sendData(JSON.stringify(results));
            setTimeout(() => { tg.close(); }, 500);
        } catch (e) {
            alert("–û—à–∏–±–∫–∞: " + e);
        }
    }

    function updateHTMLStats() {
        document.getElementById('energy-txt').innerText = sessionData.energy;
        document.getElementById('loot-txt').innerText = sessionData.loot;
        document.getElementById('coin-txt').innerText = sessionData.coins;
        document.getElementById('coords-txt').innerText = `${sessionData.x},${sessionData.y}`;
    }

    function showLog(msg) {
        const el = document.getElementById('log');
        el.innerText = msg; el.classList.add('show');
        setTimeout(() => el.classList.remove('show'), 2000);
    }
</script>
</body>
</html>